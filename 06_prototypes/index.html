<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8' />
    <meta name="description" content="The JavaScript Lessons : Some lessons on JavaScript" />

    <link rel="stylesheet" type="text/css" media="screen" href="../stylesheets/stylesheet.css">

    <title>06 Prototypes - The JavaScript Lessons</title>
</head>

<body class="sub-page">

<!-- HEADER -->
<div id="header_wrap" class="outer">
    <header class="inner">
        <a id="home_banner" href="../index.html">Home</a>

        <h1 id="project_title">Lesson 06: Prototypes</h1>
        <section id="jsbin">
            <a class="jsbin_link" target="_blank" href="http://jsbin.com/uximex/6/edit">jsBin</a>
        </section>
    </header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
    <section id="main_content" class="inner">
        <h3>Prototypes</h3>

        <p>Wie wird nun in JavaScript Vererbung realisiert? Dazu zunächst eine
            gesonderte Betrachtung des sogenannten Prototyps.</p>

        <h4>Der Prototyp</h4>

        <p>Zur Einführung betrachten wir nochmal folgenden bekannten Code. Nach Konvention
            haben wir eine Konstruktor-Funktion, Funktionen in JavaScript sind ebenso Objekte,
            also haben sie auch Properties. Eine davon: <code>prototype</code></p>

<pre><code>
function Customer( ) {

}

log(Customer.prototype);

var c1 = new Customer();
log(c1);

</code></pre>

        <p>Der log-Ausgabe können wir entnehmen, dass der Prototyp quasi ein leeres Objekt
            eines Typs (name der Konstruktor-Funktion) ist. Nun lässt sich dieser natürlich
            erweitern:</p>

<pre><code>
Customer.prototype.nr = 0;
Customer.prototype.firstname = "";
Customer.prototype.lastname = "";
Customer.prototype.registerDate = undefined;
Customer.prototype.fullname = function() {
    return this.firstname + " " + this.lastname
};

log(c1);
</code></pre>

        <p>Diese Eigenschaften und Methoden kann ich natürlich auch über ein Objekt-Literal
            zuweisen:</p>

<pre><code>
// und zum Vergleich
function Product( nr, name ) {
    this.nr = nr;
    this.name = name;
}

console.log(Product.prototype);

var p1 = new Product(1, "Berliner Pils");
console.log(p1);

Product.prototype = {

    nr: 0,
    name: "",
    price: 0.0,
    unit: "€",
    toString: function () {
        return this.name +  " (" + this.price + this.unit + ")"
    }
};

console.log(p1);

</code></pre>

        <p>Selbstverständlich kann ich einem einzelnen Objekt (nicht Prototyp) weitere eigene dynamische
            Eigenschaften zuweisen; Erweiterungen/Änderungen des Prototyps wirken sich jedoch auf
            alle(!) Objekte aus, die mit diesem Prototyp erstellt wurden.</p>

        <p>Das Ersetzen des Prototypen durch einen neuen hat übrigens keine Auswirkungen
            auf die schon erzeugten Objekte; diese halten eine Referenz auf den bei ihrer
            Konstruktion gültigen Prototypen.</p>

        <p>Zur Beantwortung der auf(ge)kommen(d)en Fragen:</p>

        <ol>
            <li>
                Warum erbt c1 die Prototype-Eigenschaften (leer angelegt), aber p1 (mit Konstruktor-Funktion
            und zwei gesetzten Eigenschaften) nicht (Merke: die Prototypen wurden jeweils
            hinterher angelegt)?
            </li>
            <li>
                Warum wirkt sich die Prototyp-Änderung auf alle Objekte aus, es sei denn
            die geänderte Eigenschaft war auf den Objekten schon explizit gesetzt?
            </li>
        </ol>

        <p>Bitte versuchen Sie sich selbst an der Lösung. Tipp: interne Objekt-Property <code>hasOwnProperty</code></p>

        <h4>Methoden und Funktionen</h4>

        <p>An dieser Stelle sei nochmal auf eine Besonderheit der Spezifikation im
            Zusammenhang mit Funktionen hingewiesen. Nochmal die Definition: <em>eine Methode
                ist eine Funktion die ein Wert einer Eigenschaft ist</em>. Ein wesentlicher
            Unterschied zw. Funktion und Methode ist (s.o.) die <code>this</code>-Referenz.</p>

        <p>In der Funktion zeigt <code>this</code> auf das globale Objekt (z.B. <code>window</code> im Browser),
            in der Methode auf das Objekt selbst (wie in Java ...). Demzufolge geht
            folgender Code schief:</p>
<pre><code>
Customer.prototype.email = "";
Customer.prototype.isValid = function () {

    // innere Funktion! Keine Methode!
    function checkEmail() {
        return this.email.match(/^\w+@\w+(\.\w{2,4})?$/);
    }

    if(
        this.firstname && this.firstname.length > 0
        && this.lastname && this.lastname.length > 0
        && checkMyEmail()
    )
        return true;
    else
        return false;
};
</code></pre>

    <h4>Articles</h4>
    <ul>
    <li><a href="http://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/">Understanding JS Prototypes</a></li>
    <li><a href="http://tobyho.com/2010/11/22/javascript-constructors-and/">JS Constructors and Prototypes</a></li>
    <li><a href="http://dailyjs.com/2012/11/26/js101-proto/">JS101: About __proto__</a></li>
    </ul>
    </section>
</div>
<script type="text/javascript" src="../javascripts/main.js"></script>
<script type="text/javascript" src="script.js"></script>
</body>
</html>
